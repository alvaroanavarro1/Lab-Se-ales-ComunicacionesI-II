% EC1482 Laboratorio de Comunicaciones Digitales% Versión 2003% Simulaciones Computarizadas - PRACTICA 7% Autor: Prof. Renny E. Badra, Ph.D.%Trimestre enero marzo 2007%EC3423. Practica 4clear;close all;%%%% ConstelacionCONST=[-1 1];%%%% Personalización de la simulacionC1=1234567; % número de carnet del integrante 1C2=8901234; % número de carnet del integrante 2m_array = [3,4,5]m_array_len = size(m_array,2);EbNo_dB_array = [4, 5, 6, 7, 8];NBIT_array = [50000, 20000, 50000, 100000, 1000000];EbNo_dB_array_len = size(EbNo_dB_array,2);for m_index = 1:m_array_len    for index_ = 1:EbNo_dB_array_len        %%%% Parámetros Básicos        NBIT=NBIT_array(index_); %nœmero de bits a simular (entero)        %%%% Codigo Hamming        m = m_array(m_index); %indice del codigo        n=2^m-1; k=n-m; %(n,k) es la tasa del codigo        if m==0; k=5; n=5; G=eye(k); H=eye(k); else        %P=[1 0 1; 1 1 1; 1 1 0; 0 1 1]; % matriz P        [H,G]=hammgen(m);        P = G(:,1:m);        %% --->Las Filas de la matriz P contienen todas las palabras de m bits con dos o mas 1s        G=[eye(k) P]; %matriz generadora del codigo        H=[G(:,k+1:n)'  eye(n-k)]; %matriz de paridad        end        %%%% Inicializaci—n de arreglos y escalares        rand('state',C1); randn('state',C2); % inicializacion de los generadores seudoaleatorios        TBIT=zeros(1,k); % buffer de s’mbolos enviados        NBLOQ=ceil(NBIT/k); % numero de bloques a simular        EBC=k/n; % energia de cada bit luego de codificar        ABC=sqrt(EBC); % amplitud de cada bit luego de codificar        ibe_a=0; %indice de bloques errados antes de la correccion        ibe_l=0; %indice de bloques errados luego de la correccion        NDE=0; %numero de datos errados        %%%% Ajuste del Eb/No        EbNo_dB=EbNo_dB_array(index_); % EbNo en dB        EbNo=10^(EbNo_dB/10); %Eb/No        No=(1/EbNo); % Dendidad del Ruido        DSR=sqrt(No/2); % Desviaci—n est‡ndar del ruido        %%%% Lazo central empieza aqu’        for nbloq=1:NBLOQ        %%%% Generaci—n del caudal de bits        TBIT=floor(2*rand(1,k));         %%%% Codificador Hamming        CBIT=mod(TBIT*G,2);        for kk=1:n; CSEN(kk)=ABC*CONST(CBIT(kk)+1); end        %%%% Canal        CSEN=CSEN+DSR*randn(1,n); % agregar ruido        %%%% Detector        DSEN=sign(CSEN); DBIT=(DSEN+1)/2; % bits detectados        %%%% Decodificador Hamming        RBIT=DBIT(1:k);        if m>0        SINDROME=mod(DBIT*H',2); % sindrome del error        NBE_a=sum(abs(DBIT-CBIT)); % numero de errores en el bloque antes de la correcci—n        if sum(SINDROME)>0; ibe_a=ibe_a+1; Nerr_a(ibe_a)=NBE_a;   end        if sum(SINDROME)>0; for kk=1:n; if H(:,kk)==SINDROME'; DBIT(kk)=not(DBIT(kk)); end; end; end        RBIT=DBIT(1:k);        NBE_l=sum(abs(DBIT-CBIT)); % numero de errores en el bloque luego de la correcci—n        if NBE_l>0; ibe_l=ibe_l+1; Nerr_l(ibe_l)=NBE_l;   end        end        NDE=NDE+sum(abs(RBIT-TBIT)); % numero de errores (SOLO DATOS) en el bloque luego de la correcci—n        end        %disp('Probabilidad de Error de Bit');         Pebit(m_index, index_) = NDE/(NBLOQ*k);          if m>0        %disp('Probabilidad de Error de Bloque');         Pebloq(m_index, index_) = ibe_l/NBLOQ;        %disp('Efectividad de Correccion de Bloque (%)');         efectividad(m_index, index_) = 100*(ibe_a-ibe_l)/ibe_a;        end    endendfigure();semilogy(EbNo_dB_array, Pebit(1,:), EbNo_dB_array, Pebit(2,:), EbNo_dB_array, Pebit(3,:));legend('Pe bit m=3','Pe bit m=4','Pe bit m=5');ylabel('Pe bit');xlabel('Eb/No');title('Probabilidad de Error de Bit para distintos valores de Eb/No');figure();semilogy(EbNo_dB_array, Pebloq(1,:), EbNo_dB_array, Pebloq(2,:), EbNo_dB_array, Pebloq(3,:));legend('Pe bloque m=3','Pe bloque m=4','Pe bloque m=5');ylabel('Pe bloque');xlabel('Eb/No');title('Probabilidad de Error de Bloque para distintos valores de Eb/No');figure();plot(EbNo_dB_array, efectividad(1,:), EbNo_dB_array, efectividad(2,:), EbNo_dB_array, efectividad(3,:));legend('Efectividad m=3','Efectividad m=4','Efectividad m=5');ylabel('Efectividad de Correccion de Bloque');xlabel('Eb/No');title('Efectividad de Correccion de Bloque para distintos valores de Eb/No');PebitPebloqefectividad