% EC1482 Laboratorio de Comunicaciones Digitales% Versión 2003% Simulaciones Computarizadas - PRACTICA 7% Autor: Prof. Renny E. Badra, Ph.D.%Trimestre enero marzo 2007%EC3423. Practica 4clear;close all;%%%% ConstelacionCONST=[-1 1];%%%% Personalización de la simulacionC1=1234567; % número de carnet del integrante 1C2=8901234; % número de carnet del integrante 2%%%% Parámetros BásicosNBIT=10000; %nœmero de bits a simular (entero)%%%% Codigo Hammingm=5; %indice del codigon=2^m-1; k=n-m; %(n,k) es la tasa del codigoif m==0; k=5; n=5; G=eye(k); H=eye(k); else%P=[1 0 1; 1 1 1; 1 1 0; 0 1 1]; % matriz P[H,G]=hammgen(m);P = G(:,1:m);%% --->Las Filas de la matriz P contienen todas las palabras de m bits con dos o mas 1sG=[eye(k) P]; %matriz generadora del codigoH=[G(:,k+1:n)'  eye(n-k)]; %matriz de paridadend%%%% Inicializaci—n de arreglos y escalaresrand('state',C1); randn('state',C2); % inicializacion de los generadores seudoaleatoriosTBIT=zeros(1,k); % buffer de s’mbolos enviadosNBLOQ=ceil(NBIT/k); % numero de bloques a simularEBC=k/n; % energia de cada bit luego de codificarABC=sqrt(EBC); % amplitud de cada bit luego de codificaribe_a=0; %indice de bloques errados antes de la correccionibe_l=0; %indice de bloques errados luego de la correccionNDE=0; %numero de datos errados%%%% Ajuste del Eb/NoEbNo_dB=6; % EbNo en dBEbNo=10^(EbNo_dB/10); %Eb/NoNo=(1/EbNo); % Dendidad del RuidoDSR=sqrt(No/2); % Desviaci—n est‡ndar del ruido%%%% Lazo central empieza aqu’for nbloq=1:NBLOQ%%%% Generaci—n del caudal de bitsTBIT=floor(2*rand(1,k)); %%%% Codificador HammingCBIT=mod(TBIT*G,2);for kk=1:n; CSEN(kk)=ABC*CONST(CBIT(kk)+1); end%%%% CanalCSEN=CSEN+DSR*randn(1,n); % agregar ruido%%%% DetectorDSEN=sign(CSEN); DBIT=(DSEN+1)/2; % bits detectados%%%% Decodificador HammingRBIT=DBIT(1:k);if m>0SINDROME=mod(DBIT*H',2); % sindrome del errorNBE_a=sum(abs(DBIT-CBIT)); % numero de errores en el bloque antes de la correcci—nif sum(SINDROME)>0; ibe_a=ibe_a+1; Nerr_a(ibe_a)=NBE_a;   endif sum(SINDROME)>0; for kk=1:n; if H(:,kk)==SINDROME'; DBIT(kk)=not(DBIT(kk)); end; end; endRBIT=DBIT(1:k);NBE_l=sum(abs(DBIT-CBIT)); % numero de errores en el bloque luego de la correcci—nif NBE_l>0; ibe_l=ibe_l+1; Nerr_l(ibe_l)=NBE_l;   endendNDE=NDE+sum(abs(RBIT-TBIT)); % numero de errores (SOLO DATOS) en el bloque luego de la correcci—nenddisp('Probabilidad de Error de Bit'); NDE/(NBLOQ*k)  if m>0disp('Probabilidad de Error de Bloque'); ibe_l/NBLOQdisp('Efectividad de Correccion de Bloque (%)'); 100*(ibe_a-ibe_l)/ibe_aendfigure();hist(Nerr_a);title('Nerr a');figure();hist(Nerr_l);title('Nerr l');