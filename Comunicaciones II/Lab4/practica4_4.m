% EC1482 Laboratorio de Comunicaciones Digitales% Versión 2003% Simulaciones Computarizadas - PRACTICA 7% Autor: Prof. Renny E. Badra, Ph.D.%Trimestre enero marzo 2007%EC3423. Practica 4clear;close all;%%%% ConstelacionCONST=[-1 1];%%%% Personalización de la simulacionC1=1234567; % número de carnet del integrante 1C2=8901234; % número de carnet del integrante 2EbNo_dB_array = [4, 5, 6, 7, 8];NBIT_array = [50000, 20000, 50000, 100000, 1000000];EbNo_dB_array_len = size(EbNo_dB_array,2);for index_ = 1:EbNo_dB_array_len    %%%% Parámetros Básicos    NBIT=NBIT_array(index_); %nœmero de bits a simular (entero)    %%%% Codigo Hamming    m=5; %indice del codigo    n=2^m-1; k=n-m; %(n,k) es la tasa del codigo    if m==0; k=5; n=5; G=eye(k); H=eye(k); else    %P=[1 0 1; 1 1 1; 1 1 0; 0 1 1]; % matriz P    [H,G]=hammgen(m);    P = G(:,1:m);    %% --->Las Filas de la matriz P contienen todas las palabras de m bits con dos o mas 1s    G=[eye(k) P]; %matriz generadora del codigo    H=[G(:,k+1:n)'  eye(n-k)]; %matriz de paridad    end    %%%% Inicializaci—n de arreglos y escalares    rand('state',C1); randn('state',C2); % inicializacion de los generadores seudoaleatorios    TBIT=zeros(1,k); % buffer de s’mbolos enviados    NBLOQ=ceil(NBIT/k); % numero de bloques a simular    EBC=k/n; % energia de cada bit luego de codificar    ABC=sqrt(EBC); % amplitud de cada bit luego de codificar    ibe_a=0; %indice de bloques errados antes de la correccion    ibe_l=0; %indice de bloques errados luego de la correccion    NDE=0; %numero de datos errados    %%%% Ajuste del Eb/No    EbNo_dB=EbNo_dB_array(index_); % EbNo en dB    EbNo=10^(EbNo_dB/10); %Eb/No    No=(1/EbNo); % Dendidad del Ruido    DSR=sqrt(No/2); % Desviaci—n est‡ndar del ruido    %%%% Lazo central empieza aqu’    for nbloq=1:NBLOQ    %%%% Generaci—n del caudal de bits    TBIT=floor(2*rand(1,k));     %%%% Codificador Hamming    CBIT=mod(TBIT*G,2);    for kk=1:n; CSEN(kk)=ABC*CONST(CBIT(kk)+1); end    %%%% Canal    CSEN=CSEN+DSR*randn(1,n); % agregar ruido    %%%% Detector    DSEN=sign(CSEN); DBIT=(DSEN+1)/2; % bits detectados    %%%% Decodificador Hamming    RBIT=DBIT(1:k);    if m>0    SINDROME=mod(DBIT*H',2); % sindrome del error    NBE_a=sum(abs(DBIT-CBIT)); % numero de errores en el bloque antes de la correcci—n    if sum(SINDROME)>0; ibe_a=ibe_a+1; Nerr_a(ibe_a)=NBE_a;   end    if sum(SINDROME)>0; for kk=1:n; if H(:,kk)==SINDROME'; DBIT(kk)=not(DBIT(kk)); end; end; end    RBIT=DBIT(1:k);    NBE_l=sum(abs(DBIT-CBIT)); % numero de errores en el bloque luego de la correcci—n    if NBE_l>0; ibe_l=ibe_l+1; Nerr_l(ibe_l)=NBE_l;   end    end    NDE=NDE+sum(abs(RBIT-TBIT)); % numero de errores (SOLO DATOS) en el bloque luego de la correcci—n    end    %disp('Probabilidad de Error de Bit');     Pebit(index_) = NDE/(NBLOQ*k);      if m>0    %disp('Probabilidad de Error de Bloque');     Pebloq(index_) = ibe_l/NBLOQ;    %disp('Efectividad de Correccion de Bloque (%)');     efectividad(index_) = 100*(ibe_a-ibe_l)/ibe_a;    endendfigure();semilogy(EbNo_dB_array, Pebit);%legend('Pe Experimental','Pe Teórico')ylabel('Pe bit')xlabel('Eb/No')title('Probabilidad de Error de Bit para distintos valores de Eb/No, m = 5');figure();semilogy(EbNo_dB_array, Pebloq);%legend('Pe Experimental','Pe Teórico')ylabel('Pe bloque')xlabel('Eb/No')title('Probabilidad de Error de Bloque para distintos valores de Eb/No, m = 5');figure();plot(EbNo_dB_array, efectividad);%legend('Pe Experimental','Pe Teórico')ylabel('Efectividad de Correccion de Bloque')xlabel('Eb/No')title('Efectividad de Correccion de Bloque para distintos valores de Eb/No, m = 5');PebitPebloqefectividad